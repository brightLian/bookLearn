# 4.1 基本类型和引用类型的值
ECMAScript 变量可能包含两种不同数据类型的值：基本类型值和引用类型值。    

基本数据类型：Undefined、Null、Boolean、Number、String。这5种基本数据类型是按值访问的。
      
引用类型的值是保存在内存种的对象。JS 不允许直接访问内存中的位置，也就是不能直接操作对象的内存空间。在操作对象时，实际是操作对象的引用而不是实际的对象。   

### 4.1.1 动态属性
对于引用类型的值，我们可以为其添加属性和方法，也可以改变和删除其属性和方法。

但是我们不能给基本类型发的值添加属性，虽然不会导致任何错误。
```javascript
let name = 'lml';
name.age = 25;
alert(name.age);  // undefined
```

### 4.1.2 赋值变量值
除了保存方式不同，从一个变量向另一个变量复制基本类型和引用类型时，也存在不同。     
从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配到的位置上。    

当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到为新变量分配到的位置上。    
不同的是，这个值的副本实际是一个指针，而这个指针指向存储在堆中的一个对象。    
复制操作结束后，两个变量实际上将引用同一个对象。因此改变其中一个变量，将会影响另一个变量。

### 4.1.3 传递参数
把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。     
基本类型值的传递就和基本类型变量的复制一致。   
引用类型值的传递就和引用类型变量的复制一致。

使用基本类型操作比较简单，但是如果换成对象就不好理解了：
```javascript
function setName(obj) {
  obj.name = 'lml';
}
let person = new Object();
setName(person);
alert(person.name)  //lml
```
即使这个对象是按值传递的，obj 也会引用来访问同一个对象。   
于是，当在函数内部为 obj 添加 name 属性后，函数外部的 person 也将有所反映；因为 person 指向的对象在堆内存中只有一个，而且是全局对象。     

所以很多人错误认为：在局部作用域中修改的对象会在全局作用域中反映出来，就说明参数是按引用类型传递的。但这不完全正确。
```javascript
function setName(obj) {
  obj.name = 'lml';
  obj = new Object();
  obj.name = 'xxs';
}
let person = new Object();
setName(person);
alert(person.name)  //lml
```
如果 person 是按引用传递的，那么 person 将会自动被修改为指向 name 属性值为 xxs 的新对象。
但是，当我们访问 person.name 时，显示的值仍是 lml。这说明即使在函数内部修改了某个参数的值，但原始的引用仍然保持不变。    
实际上，当在函数内部重写 obj 时，这个变量引用的就是一个局部对象。而这个局部对象会在函数执行完毕后立即被销毁。

### 4.1.4 检测类型
使用 typeof 可以检测基本数据类型。但是检测引用类型就需要采用 instanceof 操作符。

使用方法：result = variable instanceof constructor

如果变量是给定的引用类型的实例，那么就会返回 true。（使用 instanceof 检测基本类型始终会返回 false）
